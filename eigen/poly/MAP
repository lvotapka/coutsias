MAP
-----------------------------------------------------------------------
doit*
makefile
Bin/
new/
testpoly/
jactran/   all programs from this directory 5/7/96 (working transform)
-----------------------------------------------------------------------
in
test.f
cheb.f
     Chebyshev (scaled cosine) transform and initializations
-----------------------------------------------------------------------
     Generalized Jacobi transform: Initialize matrices
SPECS: accepts kind, alpha, beta, bctype (Gauss, Gauss-Radau, Gauss-Lobatto)
       produces:   
rec.f---    convolution by X (x recurrence)
            integration operator (deriv. recurrence)
***** The only place that knows about the particular polynomial family
        employed is the routine that computes the X and B matrices. This is
        only invoked upon initialization. Matrices X and B are then known.
gauss.f---  Collocation points and weights
      gaussq(kind, n, alpha, beta, kpts, endpts, b, t, w)
      solve(shift, n, a, b)
      class(kind, n, alpha, beta, b, a, muzero)
           ---    based on symmetric recurrence, point-evaluation functionals
          dgamma.f
      gaussq2(n, d, e, z, ierr)
jacini.f---    Transform matrices
        The Fourier matrices are also computed once and then known,
        however that computation is truncation dependent (normalizations are)
        so it needs to be redone if truncation changes. This truncation
        dependence affects pointvalues needed, while fourier coefficients can
        be truncated at any point.
poly.f---   point evaluations based on X-matrix recurrence coefficients
     jac_q(kind,x,al,be,k,n,q)
***           collocation integration operator
***           differentiation and collocation differentiation operators
***           integration-preconditioned differential operators
               based on X and B precomputed coefficients
jac.f---  General polynomial transform: cannot yet handle Gegenbauer
     JACT(M_MAX,M,DATA,TRANSFORM, ISIGN,JACM,W,G,b)
gen_pack.f---  B^p(X+a)^k operator for chosen family
     cond1(maxm,pp,kk,OP,aspect,debug,buff,X,B)
band_op.f
     band_op(mmax,m,q,n,P,OP,pn,CP,VP,HP,CHP,debug,buff1,U,bb,cc)
     ul_sol(mmax,m1,q,n1,P,OP,pn,CP,VP,HP,CHP,U,cond,sing,case,
            debug,buff1,U0,bb,cc)
-----------------------------------------------------------------------
band_pack.f
     bbadd(mmax,m,al,bl,cl,au,bu,cu,A,B,C,alpha,beta,buff)
     bbmul(mmax,m,al,bl,cl,au,bu,cu,A,B,C,buff)
     bfcon(mmax,m,al,au,A,B,buff)
     bfmul(mmax,m,n,al,au,A,B,C,bb,cc,buff)
     opmul(mmax,m,n,al,au,A,B,C,bb,cc,buff)
full_pack.f
          limits.h
NOTE: for purposes of computing BC, a separate capability for computing
      point-evaluation functionals is needed. Routine poly.f should do this.
      Essentially, there can be several versions; two are special, orthonormal
      and standard. The advantage of the orthonormal is that X-recurrence is
      symmetric. The advantage of standard is that coefficients are integers, or
      have simple form. The gauss routine defines internally the recurrence
      coefficients in CLASS for symmetric recurrence. 
----> For the time being will only implement standard, nonsymmetric form.
      When I figure out the connection between X and B fr the symmetric case
      it will be implemented using the coefficients as computed in CLASS.
C-----------------------------------------------------------------------
advec1
	limits.h
	fcos2ini
	fcos2t
	dgesv
