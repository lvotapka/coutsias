*************************************************************************
                     band_op.f
*************************************************************************
      subroutine band_op(mmax,m,q,n,P,OP,pn,CP,VP,HP,CHP,debug,buff1,
     _                   U,bb,cc)
C-----------------------------------------------------------------------
C INITIALIZE ARRAYS FOR 2*p+1 BANDED SOLVER: UL factorization,
C                                            Constraints,
C    2nd order differential operator         Homogeneous solutions,
C       B^2_[2](x+a^2 preconditioning        adjustment operators.
C
C      ***    P^(p)_[2]+B_[2] P^(p-1)+B^2_[2] P^(p-2)   ***
C
C  P^(p-k) = alpha(k,p-k)T_(p-k)+alpha(k,p-k-1)T_(p-k-1)+...+alpha(k,0)T_0
C
C  Caller must precalculate the Chebyshev expansions of the P^(k) (whose
C  index gives the max. allowable degree for each) and provide them in the
C  argument array alpha(0:2,0:p).
C  In this geometry, r=X+a(spect) and for a>1 (annulus) or a=1 (disk)
C  all expressions are derived in the same way. However for the magic
C  combinations (x+1)^2 D^2 and (x+1) D an entirely different preconditioner
C  is available. (This might be related to some connection between even or odd
C  subclass and the interval (0,1)?)
C   This is not in the pattern of the present banded solver, which
C  assumes B^2_[2] preconditioning.
C-----------------------------------------------------------------------
C Arguments
C           mmax       : leading column dimension of arrays (0:m_max)
C
C           m,n         : effective  dimensions are 0:m,*,0:n
C           q           : (symmetric) bandwidth of operator
C           P           : The (eventually factored) operator stored in band form
C           OP         : The original operator stored in band form
C           pn          : number of top null-rows for operator
C           CP          : The two constraints, assumed identical for sine
C                           and cosine modes (1: outer, 2: inner)
C           VP          : The "BC" values, (out:in,cos:sin,0:n/2)
C           HP          : The homos: (0:m,hom_0:hom_1,0:n/2)
C           CHP         : CHP(i,j) = <hom_i , CP_j> (inverted)
C           alpha(k,p-k): the (supplied) array of expansion coeffs. for the
C                         polynomial coefficients P^(p-k),k=0,1,2
C-----------------------------------------------------------------------
*************************************************************************
C-----------------------------------------------------------------------
C SOLVE BANDED SYSTEM in U*L factored form:
c                           -----  U : P(i, 1.. q,j), unit diagonal  ---
c                           -----  L : P(i, 0..-q,j)                 ---
C-----------------------------------------------------------------------
      subroutine ul_sol(mmax,m1,q,n1,P,OP,CP,VP,HP,CHP,U,cond,sing,
     _                  case,debug,buff1,U0,bb,cc)
C-----------------------------------------------------------------------
C        m_max: max column dimension
C           m,n         : effective  dimensions are 0:m,*,0:n
C           q           : bandwidth of operator
C           U           : input-output array
C           P           : The operator stored in band form
C-----------------------------------------------------------------------
*************************************************************************
           band_pack.
*************************************************************************
-----------------------------------------------------------------------
C           ----------<   B  B  A  D  D  .  f    >----------
C-----------------------------------------------------------------------
        subroutine bbadd(mmax,m,al,bl,cl,au,bu,cu,A,B,C,alpha,beta,buff)
C-----------------------------------------------------------------------
C Add two banded matrices A,B and put result in C. Compute to make
C                 C = alpha*A + beta*B
C sure that cu/l >= max(au/l,bu/l) else C has wrong bandwidth
C Normally caller is responsible for supplying correct bandwidth specs.
C This operation does not deteriorate correctness in given truncation.
C A can be overwritten by C
C-----------------------------------------------------------------------
C           ----------<   B  B  M  U  L  .  f    >----------
C-----------------------------------------------------------------------
          subroutine bbmul(mmax,m,al,bl,cl,au,bu,cu,A,B,C,buff)
C-----------------------------------------------------------------------
C Multiply two banded matrices A,B and put result in C. Compute to make
C sure that au/l+bu/l=cu/l else C has wrong bandwidth
C ***>>> If all are saved by diagonal (i.e. the first mm rows are correct),
C        then after multiplication the last au rows are contaminated: hence
C        don't compute them.
C        upper au rows return with zeroes; must pad banded matrices with enough
C        extra correct entries so product is correct to desired truncation,
C        which means the padding depends on how many iteration levels a certain
C        matrix is going to seed.
C buff   : a global variable characterizing the code. Set as parameter,
C          since it determines true dimension of all banded matrices in code.
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C           ----------<   B  F  C  O  N  .  f    >----------
C-----------------------------------------------------------------------
          subroutine bfcon(mmax,m,al,au,A,B,buff)
C-----------------------------------------------------------------------
C al, au: lower and upper bands of banded matrix A
C only one page of an operator is copied per call
      implicit none
      integer buff,mmax,m,al,au
      integer i,k,l,ll,lu
      double precision A(0:mmax+buff,al:au)
      double precision B(0:mmax,0:mmax)
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C           ----------<   B  F  M  U  L  .  f    >----------
C-----------------------------------------------------------------------
          subroutine bfmul(mmax,m,n,al,au,A,B,C,bb,cc,buff)
C-----------------------------------------------------------------------
C Multiply banded matrix A times full matrix B and put result in C.
C Can have B = C so that second input may or may not be overwritten
C Use, e.g. for various preconditioning operations.
C al, au: lower and upper bands of banded matrix A
C Note that only one page of an operator is done per call.
      implicit none
      integer buff,mmax,m,n,al,au
      integer i,j,k,kk
      double precision A(0:mmax+buff,al:au)
      double precision B(0:mmax,0:1,0:*)
      double precision C(0:mmax,0:1,0:*)
      double precision bb(0:mmax)
      double precision cc(0:mmax)
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C           ----------<   O  P  M  U  L  .  f    >----------
C-----------------------------------------------------------------------
          subroutine opmul(mmax,m,n,al,au,A,B,C,bb,cc,buff)
C-----------------------------------------------------------------------
C Multiply banded operator A times full matrix B and put result in C.
C Can have B = C so that second input may or may not be overwritten
C Use, e.g. for various preconditioning operations.
C al, au: lower and upper bands of banded matrix A
C Note that only one page of an operator is done per call.
      implicit none
      integer buff,mmax,m,n,al,au
      integer i,j,k,kk
      double precision A(0:mmax+buff,al:au,0:*)
      double precision B(0:mmax,0:1,0:*)
      double precision C(0:mmax,0:1,0:*)
      double precision bb(0:mmax)
      double precision cc(0:mmax)
C-----------------------------------------------------------------------
*************************************************************************
                   cheb_pack.f
*************************************************************************
C------------------------------------------------------------------
      SUBROUTINE D1MAT(ML, A1)
C------------------------------------------------------------------
      SUBROUTINE R1D1MAT(ML, A1, aspect)
C------------------------------------------------------------------
      SUBROUTINE R2LAPNMAT(ML,MODE, R2LAP,ASPECT)
C------------------------------------------------------------------
      SUBROUTINE R2LAPNMATMUL(ML,MODE, RDR,R2LAP)
C-----------------------------------------------------------------------
C               -----------<    deriv.f   >------------
C       compute the derivatives of a Fourier (theta)-Chebyshev (x)
C       expansion
C-----------------------------------------------------------------------
        subroutine d1th(mmax,m,n,A,B,period)
C-----------------------------------------------------------------------
        subroutine d1r(mmax,m,n,A,B)
C-----------------------------------------------------------------------
        subroutine r1d1r(mmax,m,n,A,B,aspect)
C-----------------------------------------------------------------------
      SUBROUTINE CHEBINT(mmax, m, n, A,V)
C--- Accepts an array whose columns are the Chebyshev coeffs. of a set
C    of functions. Produces the integrals of these functions over [-1,1].

C-----------------------------------------------------------------------
        subroutine convol(mmax,m,vec,mat)
C-----------------------------------------------------------------------
C                 -------<  c o n d 1 . f  >-------
C-----------------------------------------------------------------------
                subroutine cond1_mat(maxm,pp,kk,OP,aspect,debug,buff)
C-----------------------------------------------------------------------
C     initialize various banded preconditioners
C     PHASE 1: Chebyshev family
C       
C     PHASE 2: Jacobi of arbitrary type.
C       will characterize by giving recurrence functions for X and B.
C-----------------------------------------------------------------------
C-- Build type 1 (integration) preconditioner matrix B_[2]^pp (x+a)^kk
C   with bands -(pp+kk):(pp+kk)
C   All bands are introduced, even those that may contain zeroes.
C   The computation is carried over enough additional modes so that
C   truncation at maxm is exact.
C-----------------------------------------------------------------------
      implicit none
      integer maxm,pp,kk,debug,i,j,k,mmax,buff
      double precision aspect
      double precision OP(0:maxm+buff,-pp-kk:pp+kk)
      double precision a1(-16:16)
C-----------------------------------------------------------------------
          subroutine rdiv(mmax,m,n,U,U0,a)
C Experimental division routine. Intended for the Fourier-Chebyshev
C Divides U by x+a, puts result in U0
C-----------------------------------------------------------------------
*************************************************************************
                full_pack.f
*************************************************************************
C-----------------------------------------------------------------------
           SUBROUTINE FFMUL(MLIM,ML,KL,NL,A,B,C)
C-----------------------------------------------------------------------
C --- Multiply two matrices using a GAXPY algorithm (Gollub/VanLoan p.12)
C --- Assumes common leading column dimension (MLIM)
C-----------------------------------------------------------------------
      subroutine copym(m1,m2,m,n,indata,outdata)
C-----------------------------------------------------------------------
C Copy array into another; assumes different leading column dimensions
C-----------------------------------------------------------------------
*
************ From here on, arrays are dimensioned 0:*****************
*
      subroutine mug(data,mmax,imin,imax,jmin,jmax)
C-----------------------------------------------------------------------
C   dimensions arays from 0.
        implicit none
        integer i,j,imax,jmax,mmax,imin, jmin
        double precision data(0:mmax,0:*)
C-----------------------------------------------------------------------
      subroutine remmod(data,m_act,n_act)
C-----------------------------------------------------------------------
           subroutine point_mult(A,B,C,m_max,m,n)
C-----------------------------------------------------------------------
           subroutine addm(a0,A,b0,B,C,m_max,m,n)
C-----------------------------------------------------------------------
        subroutine error(mmax,m,n,xcomp,x,p,norm)
C-----------------------------------------------------------------------
C--compute a specified norm of the difference of two fields
C-----------------------------------------------------------------------
*************************************************************************
